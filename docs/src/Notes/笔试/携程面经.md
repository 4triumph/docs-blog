# 本人面经

## 我的一面

### htmlcssjs是怎么渲染上去的，从url开始说

#### 1. 输入 URL 并发起请求

- **用户输入 URL**（例如 `https://example.com`）在浏览器的地址栏中。
- 浏览器通过 DNS 解析将域名转换为 IP 地址，并向该 IP 地址的服务器发起 HTTP/HTTPS 请求。请求的目标是该服务器上托管的 HTML 页面或资源。

#### 2. 服务器返回响应

- **服务器响应**：服务器接收到请求后，会返回包含 HTML 文档的响应（通常是 `index.html`）。
- **浏览器收到 HTML 文件**：浏览器收到服务器返回的 HTML 文档后开始解析。

#### 3. 解析 HTML

- **HTML 解析器工作**：浏览器从上到下解析 HTML 文件，遇到各种 HTML 标签。根据这些标签，浏览器构建出一个称为 **DOM（Document Object Model）** 的结构。

- 遇到外部资源（CSS 和 JavaScript 文件）

  ：

  - 当浏览器遇到 `<link>` 标签（CSS 文件）时，它会发出另一个请求来获取 CSS 文件。
  - 遇到 `<script>` 标签（JavaScript 文件）时，它会发出请求获取 JavaScript 文件（如果是 `src` 引入的外部文件），并执行其中的脚本。

#### 4. CSS 加载和解析

- **CSS 解析器工作**：当浏览器获取到 CSS 文件后，它会解析 CSS，构建 **CSSOM（CSS Object Model）**，这是 CSS 样式的树状结构，结合 DOM 树，浏览器决定元素的样式。
- CSS 控制了页面的布局、颜色、字体等视觉样式。

#### 5. JavaScript 执行

- **JavaScript 加载和执行**：当浏览器解析到 JavaScript 文件时，JS 引擎会开始执行其中的代码。JavaScript 可以操作 DOM（修改 HTML 结构）和 CSSOM（修改样式）。
- **脚本可能阻塞渲染**：如果 JavaScript 文件位于页面的 `<head>` 中，浏览器会先下载和执行它，然后才继续解析后续的 HTML 内容。这也是为什么通常建议将 JS 文件放在 `<body>` 的底部，或使用 `defer` 或 `async` 以非阻塞方式加载。

#### 6. 构建渲染树

- **渲染树**：当浏览器构建了 DOM 和 CSSOM 后，它会结合这两个树来生成 **渲染树**。渲染树包含每个节点如何显示在页面上的信息。
- 渲染树是最终决定元素如何呈现在屏幕上的结构，包括每个元素的大小、颜色、位置等。

#### 7. 布局和绘制

- **布局**：浏览器计算每个元素在页面中的确切位置和大小。
- **绘制**：浏览器将渲染树上的内容绘制到屏幕上，这个过程称为 "painting"。

#### 8. JavaScript 操作 DOM

- **动态操作**：JavaScript 可以动态修改 DOM，比如添加、删除或修改 HTML 元素，也可以通过操作样式改变元素的显示效果。
- **事件驱动交互**：JavaScript 还可以通过事件监听器（如 `onclick`、`onmouseover`）来响应用户交互，更新页面内容。

#### 9. 页面完成渲染

当所有的 HTML、CSS 和 JavaScript 文件都加载完毕，页面的所有元素被正确布局并绘制到屏幕上，页面渲染过程基本完成。

#### 总结

从输入 URL 到页面渲染的过程如下：

1. **输入 URL** → 浏览器发起 HTTP/HTTPS 请求。
2. **服务器响应 HTML 文件**。
3. **解析 HTML** → 构建 DOM 树。
4. **加载 CSS** → 构建 CSSOM 树。
5. **加载和执行 JavaScript** → 操作 DOM 和 CSS。
6. **构建渲染树** → 结合 DOM 和 CSSOM。
7. **布局和绘制** → 元素显示在屏幕上。
8. **JavaScript 动态操作** → 页面交互和内容更新。

整个过程在几毫秒到几秒内完成，取决于网络延迟、文件大小和浏览器性能。

### 跨域

### 三次握手四次挥手，过程原因

### url上的编码导致英文或中文不显示，怎么办

### 防抖节流

### 时间循环过程

### BFC

### 事件冒泡 事件委托

### 数组方法

### map forEach区别

### 平常是怎么找错的，trycatch用过吗，原理过程什么的

### v-for和v-if优先级，可以放一起吗

### 用过vue2吗，和3的区别，优化

### url请求资源后怎么获取资源

### 重绘重排

### 除了springboot，使用过node.js写后端吗

### js和css你是怎么实现动画效果的





**剩下忘了，也没说云录制重放密码....**

# 网络面经

## 一面

### 箭头函数和普通函数的区别

#### 1. **`this` 绑定机制不同**：

- **箭头函数**：不会创建自己的 `this`，它的 `this` 是在**定义时**继承自外层作用域的 `this`，并且无法通过 `call`、`apply` 或 `bind` 来改变 `this` 的指向。
- **普通函数**：`this` 取决于**调用时**的上下文，可以通过 `call`、`apply`、`bind` 来显式修改 `this` 的指向。

#### 2. **构造函数**：

- **箭头函数**：不能作为构造函数调用，不能使用 `new` 关键字实例化对象。
- **普通函数**：可以作为构造函数调用，并且能够通过 `new` 关键字生成实例。

#### 3. **`arguments` 对象**：

- **箭头函数**：没有自己的 `arguments` 对象，如果需要使用 `arguments`，可以通过外层函数的 `arguments` 获取。

- **普通函数**：有自己的 `arguments` 对象，可以访问传入的参数。

  ```javascript
  function normalFunc() {
    console.log(arguments); // 输出：{ 0: 1, 1: 2, 2: 3 }
  }
  
  const arrowFunc = () => {
    console.log(arguments); // 报错：arguments is not defined
  };
  
  normalFunc(1, 2, 3);
  arrowFunc(1, 2, 3);
  
  ```


#### 4. **`prototype` 属性**：

- **箭头函数**：没有 `prototype` 属性，因此不能作为构造函数使用。

- **普通函数**：有 `prototype` 属性，用于定义构造函数创建的对象的共有属性或方法。

  ```javascript
  const arrowFunc = () => {};
  const normalFunc = function() {};
  
  console.log(arrowFunc.prototype);  // undefined
  console.log(normalFunc.prototype); // 正常输出 {}
  
  ```

  

### 事件循环

是 JavaScript 处理异步操作的一种机制。由于 JavaScript 是单线程的语言，它只能同时处理一件事情。为了确保在处理耗时任务时不会阻塞整个程序，JavaScript 引入了事件循环来处理异步任务，使得异步操作能够在主线程之外执行，并在适当的时机返回结果。

### 回调地狱如何解决

#### 1. **使用 Promise**

Promise 是一种解决回调地狱的机制。通过链式调用，Promise 使得嵌套的回调变得扁平化，并提供了 `catch` 方法用于统一错误处理。

#### 2.使用 async/await

#### 3. **模块化和函数拆分**

将每个回调函数封装成单独的函数，有助于简化嵌套结构并提升代码的可读性。

### 节流防抖

节流是指在一定时间内只允许函数执行一次。即使事件被频繁触发，函数也会按固定的时间间隔执行。九宫格布局

防抖是指当事件被频繁触发时，只有在事件停止触发的一段时间后，函数才会被执行。如果在这段时间内事件又被触发，计时器会重新开始计时。

九宫格布局

```html
<style>
    .container {
      display: flex;
      flex-wrap: wrap;
      width: 300px;
      height: 300px;
    }
    .container > div {
      flex: 1 0 33.33%;
      display: flex;
      justify-content: center;
      align-items: center;
      border: 1px solid #000;
      box-sizing: border-box;
    }
  </style>
</head>
<body>

  <div class="container">
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <div>4</div>
    <div>5</div>
    <div>6</div>
    <div>7</div>
    <div>8</div>
    <div>9</div>
  </div>

</body>
</html>
```

### flex:1 含义

```css
flex: flex-grow flex-shrink flex-basis;
```

**`flex-grow`**：定义了 Flex 项目如何在父容器中按照剩余空间进行扩展。

**`flex-shrink`**：定义了 Flex 项目在空间不足时如何缩小。

**`flex-basis`**：定义了 Flex 项目的初始大小（主轴方向上）。

### margin边距重叠

通常发生在垂直方向上。当两个相邻元素（或相邻的上下边距）各自有 `margin` 时，可能会出现 **重叠**，导致它们的垂直间距并不是两个 `margin` 之和，而是取其中较大的一个 `margin` 值。

### 白屏性能优化

是指用户打开一个网页时，页面加载时间较长，导致在一段时间内屏幕完全空白，用户无法看到内容或进行交互。这通常是由于前端资源加载过慢、渲染阻塞、JavaScript 执行时间过长等原因引起的。

### 强缓存和协商缓存

强缓存指的是在缓存有效期内，浏览器直接从本地缓存读取资源，而不发起请求到服务器

协商缓存指的是在缓存过期或缓存不可用时，浏览器向服务器发起请求，并通过与服务器的某种验证机制，来确认缓存是否仍然有效。如果资源没有修改，服务器会告知浏览器继续使用缓存；否则，服务器会返回最新资源。



### vue和react的区别

###  react diff算法

### vue和react diff算法的区别

### 虚拟DOM

是前端框架（如 React、Vue 等）中用来提升页面渲染性能的重要技术。通过虚拟 DOM，可以减少对真实 DOM 的频繁操作，进而提高页面性能。

### react错误捕获

### 有没有写过自定义hook 如果想要定义一个useSearch该怎么设计

### 说一下常用的loader和plugin

在 Webpack 中，`loader` 和 `plugin` 是用于处理不同类型资源和增强构建过程的两类工具

`Loader` 的主要作用是**对模块的源代码进行转换**。Webpack 默认只能处理 JavaScript 模块，其他类型的文件（如 CSS、图片、字体等）需要通过 `loader` 来处理。

`Plugin` 的作用是**扩展 Webpack 的功能**，它们可以在构建过程中执行更复杂的任务，如优化打包、资源管理、环境变量注入等。

### 有没有写过loader或plugin

### ==和===的区别

### Git rebase和git revert区别

`git rebase` 是一个用于重新整理提交历史的命令，它将一个分支的提交应用到另一个基础提交上。常见的应用场景是将一个分支的更改 "移植" 到另一个分支的最新提交之上，以保持提交历史的线性。

`git revert` 是一个用于撤销某个特定提交的命令，它通过**创建一个新的提交**来反向应用指定提交的更改，而不会修改提交历史。

### 有没有用过git stash

将当前未提交的工作内容（包括修改和暂存的内容）存储起来，让工作区回到干净的状态

### 解决过的印象深刻的bug

### ts有什么好处

是一种 JavaScript 的超集，提供了静态类型检查和现代 JavaScript 特性的支持。

### Ts 工具类型

### 首屏加载优化

首屏加载优化是提升网页性能和用户体验的重要步骤，目的是减少页面初次渲染的时间。以下是常见的首屏加载优化策略：

#### 1. **减少资源体积**

- **代码压缩**：通过压缩 HTML、CSS、JavaScript 文件，减少资源的大小。可以使用工具如 `UglifyJS`、`Terser`、`CSSNano` 等。
- **图片优化**：采用合适的图片格式（如 WebP、JPEG），使用图片压缩工具，减少图片体积。对于图标和小图片可以使用 SVG 格式。
- **使用 Gzip/Brotli 压缩**：启用服务器端压缩传输文件，减少网络传输的数据量。

#### 2. **减少资源请求数量**

- **代码分割**：通过 Webpack、Vite 等工具进行代码分割，按需加载必要的 JS 和 CSS 资源，避免一次性加载过多文件。
- **懒加载**：对于不在首屏展示的资源如图片、组件等，可以使用懒加载（Lazy Loading）。在 Vue.js 中，可以通过 `v-lazy` 或 `dynamic import` 来实现。
- **合并资源**：将一些零碎的 CSS 或 JavaScript 文件进行合并，减少 HTTP 请求数量。

#### 3. **缓存优化**

- **强缓存与协商缓存**：使用浏览器缓存策略，将不会频繁更新的资源（如字体、图片）进行强缓存或协商缓存，避免重复加载。
- **服务端缓存**：启用 CDN 缓存，利用地理位置就近访问服务器，减少网络延迟。

#### 4. **异步加载资源**

- **CSS、JS 文件异步加载**：对非关键的 CSS 文件、JS 文件，可以通过 `async` 或 `defer` 属性异步加载，避免阻塞 HTML 渲染。
- **内联关键 CSS**：将首屏渲染所需的关键 CSS 直接内联到 HTML 中，避免外部样式表阻塞渲染。

#### 5. **使用 SSR 或 CSR 优化**

- **服务端渲染（SSR）**：通过服务器生成完整 HTML 发送给客户端，减少首屏等待时间。Vue、React 都支持 SSR（如 Nuxt.js 和 Next.js）。
- **静态生成（SSG）**：在构建时生成静态 HTML 页面，适用于不频繁更新的页面内容。
- **客户端渲染（CSR）优化**：使用 CSR 时可以进行懒加载、骨架屏技术，提前渲染出页面框架部分，给用户更快的视觉反馈。

#### 6. **预加载与预渲染**

- **资源预加载（preload）**：使用 `<link rel="preload">` 标签对首屏的关键资源（字体、JS、CSS 等）进行预加载。
- **预渲染（prerender）**：通过 `<link rel="prerender">` 对下一个可能访问的页面进行预渲染，提升跳转后的加载速度。

#### 7. **减少阻塞渲染的资源**

- **优化第三方脚本**：减少或异步加载第三方库（如广告、分析工具）的资源，避免它们影响页面渲染。
- **使用 `font-display: swap`**：减少字体加载时的阻塞渲染，允许浏览器在字体加载前使用系统字体进行渲染。

#### 8. **骨架屏**

- **骨架屏技术**：通过在页面加载时先渲染出一个简单的骨架页面框架，给用户提供视觉反馈，减少页面空白时间，提升用户体验。

#### 9. **减少 DOM 和 CSSOM 渲染阻塞**

- **减少 CSS 文件的大小和数量**，避免过多的 CSS 阻塞页面渲染。
- **减少 DOM 元素的层级**，过多的 DOM 节点会导致布局计算复杂度上升，从而影响渲染性能。

#### 10. **服务端推送（HTTP/2 Push）**

- **HTTP/2 Server Push**：通过服务器主动推送资源，提前加载必要的文件，减少客户端请求等待时间。

### 首屏js加载

#### 1.**使用 `defer` 和 `async` 加载 JavaScript**

- **`defer` 属性**：当 JavaScript 文件带有 `defer` 属性时，它会异步加载，并且在 DOM 解析完成后再执行，保证不会阻塞 HTML 渲染。多个带 `defer` 的脚本会按照它们在文档中出现的顺序执行。
- **`async` 属性**：`async` 也会异步加载 JavaScript 文件，但文件下载完后会立即执行，并不会等待 DOM 解析完成，适用于不依赖其他脚本的文件。

#### 2. **拆分和按需加载（代码分割）**

- 使用 **代码分割**（Code Splitting）将首屏不需要的 JavaScript 文件延后加载。现代打包工具（如 Webpack 和 Vite）可以通过 `dynamic import` 动态加载模块，按需加载页面所需的部分代码，而不是一次性加载所有资源。

#### 3. **懒加载 JavaScript**

- 对于非关键的 JavaScript（如非首屏展示的组件、功能模块），可以使用懒加载。Vue、React 等框架支持懒加载组件，能够延迟加载并减少首屏 JavaScript 的体积。

## 二面

### ref有什么用

`ref` 是一个用于在模板中获取 DOM 元素或组件实例的属性。

### react生命周期

### 父子组件传值

### 手撕 随机生成50个div 分布在页面中 碰撞检测

### 手撕 移动端上中下布局

## 一面

### BFC（Block Formatting Context，块级格式化上下文）

是 CSS 中一种布局机制，它决定了元素如何对其内容和子元素进行布局，并与其他元素进行交互。理解 BFC 对解决一些 CSS 布局问题，比如**边距重叠**、**浮动元素清除**、**避免文本环绕浮动**，有着重要的意义。

### 如何触发 BFC

有几种常见的方式可以触发 BFC：

1. **设置 `overflow`**: 设置元素的 `overflow` 属性为 `hidden`、`auto` 或 `scroll`。

   ```
   css复制代码.bfc {
     overflow: hidden;
   }
   ```

2. **浮动元素**： 当元素的 `float` 值为 `left` 或 `right` 时，它会形成 BFC。

   ```
   css复制代码.bfc {
     float: left;
   }
   ```

3. **绝对定位元素**： 设置 `position` 为 `absolute` 或 `fixed`。

   ```
   css复制代码.bfc {
     position: absolute;
   }
   ```

4. **`display` 值为 `inline-block`、`table-cell`、`table-caption`**：

   ```
   css复制代码.bfc {
     display: inline-block;
   }
   ```

5. **设置 `display: flow-root`**： 这是专门用于创建 BFC 的新方式，在现代浏览器中可用。

   ```
   css复制代码.bfc {
     display: flow-root;
   }
   ```

### BFC 的应用场景

1. **清除浮动**： 浮动元素会影响到正常文档流中的元素。当父元素没有高度时，通过触发 BFC，可以让父元素包裹浮动的子元素，避免父元素高度塌陷。

   ```
   css复制代码.clearfix {
     overflow: hidden;
   }
   ```

2. **解决外边距重叠问题**： 两个块级元素之间的垂直外边距可能会合并，通过创建 BFC，可以避免这种重叠。

   ```
   css复制代码.bfc {
     overflow: hidden;
     margin-top: 20px;
   }
   ```

3. **防止内容被浮动元素覆盖**： 当浮动元素出现在普通文档流中时，文字会环绕浮动元素。通过创建 BFC，可以避免文本环绕浮动元素。

### 事件冒泡 事件委托

**事件冒泡**是 DOM 事件模型中的一种行为，指的是当某个事件发生在某个元素上时，事件会从该元素开始，逐层向上冒泡到其父元素，直到到达 `document` 对象。这意味着，事件可以在其父元素中被捕获，允许父元素对其子元素的事件进行处理。

### 跨域

### 6.数组方法

### 7.map forEach的区别

**返回值**:

- `forEach`：无返回值（返回 `undefined`）。
- `map`：返回一个新数组，数组的每个元素是通过调用提供的函数处理后的结果。

**用途**:

- `forEach`：用于对每个元素执行某些操作（如打印、修改）。
- `map`：用于将数组中的每个元素转换为新元素，并返回新数组。

### 8.bind call apply的区别

**`bind`**:

- 用于创建一个新函数，绑定特定的 `this` 值和初始参数。返回的新函数可以在未来调用。

```javascript
const obj = { value: 42 };
const getValue = function() {
    return this.value;
};

const boundGetValue = getValue.bind(obj);
console.log(boundGetValue()); // 输出 42
```

**`call`**:

- 立即调用函数，并指定 `this` 的值和参数。参数以逗号分隔。

```javascript
console.log(getValue.call(obj)); // 输出 42
```

**`apply`**:

- 立即调用函数，类似于 `call`，但参数以数组的形式传递。

```javascript
console.log(getValue.apply(obj)); // 输出 42
```

### 9.promise

`Promise` 是一种用于处理异步操作的对象，表示一个尚未完成但将来可能会完成的操作。Promise 有三种状态：

- **Pending（进行中）**：初始状态，既不是成功，也不是失败。
- **Fulfilled（已完成）**：操作成功完成。
- **Rejected（已拒绝）**：操作失败。

### 10.async await

### 11.事件循环，说出输出顺序



## 一面

### js数据类型

### 类型判断有哪些方法

### 解释一下闭包

### 有什么优缺点

### 闭包怎么规避内存泄漏

### js原型？怎么实现继承？原型实现继承有啥缺点？我只知道原型的优点，没准备缺点😭

### call apply bind区别

### js ==中涉及到的类型转换？就讲了数字和字符串以及 布尔型和01

### 手写promise？这个真没准备

### 浏览器事件触发有什么过程

### 如果这个事件触发我只想要捕获或者只想要冒泡怎么实现？这个不会

### 讲一下事件委托

### vue中如果许多子元素绑定同一种事件，怎么处理，是像浏览器一样放到父元素上吗？没答上来

### vue中了解MVVM吗

### Vue2和Vue3在响应式原理有啥区别

### vue中父子元素如何传递事件?勉强答了props和emit

